shader tissuePatternCircles(
    // Can be interpolated from an 's' or 't' variable attached to the geometry
    float s = 0 [[int lockgeom = 0]],
    float t = 0 [[int lockgeom = 0]],

    // Simplex Noise
    float simHeight = 0.0035,
    int simFreq = 60,

    // Perlin Noise
    float height = 0.005,
    int frequency = 5,

    output color resultRGB = 0,
    output float dispOut = 0)
{
    // Mirroring
    float s_repeats = 8;
    float t_repeats = 3;
    float ss = mod(s * s_repeats, 1);
    float tt = mod(t * t_repeats, 1);
    
    // Circle properties
    float innerRadius = 0.0;
    float outerRadius = 0.010;

    // Row properties
    int rings = 3;
    float distanceBetweenRows = outerRadius * 5;

    // Displace and colour blank canvas
    resultRGB = color(0.95, 0.95, 0.95);
    dispOut = height * (float)noise("perlin", P * frequency);

/// STIPPLING START
    float stipRepeats = 2;
    float stipSS = mod(s * stipRepeats, 1);

    color lineColour = color(0.0, 0.0, 0.0);
    float lineWidth = 0.001;
    
    // Draw line
    if (stipSS < lineWidth)
    {
        lineColour = color(0.95, 0.95, 0.95);
    }
    
    // Incrementally indent line, to create stippled effect
    float waveLength = 3.141 * 30;
    color wave = color(sin(waveLength * t));
    wave *= lineColour;

    dispOut += wave[0] / 150;
/// STIPPLING END

/// PATTERN START
// The following part is adapted from:
// Kesson, M., 2002. OSL Rosette. [online]
// Available from: https://www.fundza.com/rfm/osl/rosette/index.html
// Accessed [25 March 2021]
    
    // Randomly seed number of circles per row
    // Circles counted on physical object as reference: Small = 18, 9, 0   Medium = 32, 22, 14   Large = 50, 44, 36
    float circleSeed = (float)noise("cell", s_repeats * s, t_repeats * t);

    if (circleSeed < 0.5)
    {
         circleSeed += 0.5;
    }

    float a = circleSeed * 50;
    float b = circleSeed * 44;
    float c = circleSeed * 36;
    point circlesPerRing = point((int)a, (int)b, (int)c);

    float s_centre = 0.5;
    float t_centre = 0.5;
    float radiusOffset = (float)noise("cell", s_repeats * s, t_repeats * t) * 0.2;
    float circleSize = (15 * outerRadius) + radiusOffset;
    point stPoint = point(ss, tt, 0);
    point rotPoint;
    float rotS;
    float rotT;

    // Offset centre position of pattern
    float offsetSeed = (float)noise("cell", s_repeats * s, t_repeats * t) - 0.5;

    // Centre point of circle (to rotate around)
    point centrePoint = point(s_centre - (offsetSeed * 0.1), t_centre - (offsetSeed * 0.1), 0);
    point axisPoint = point(s_centre, t_centre, 1);

    // Draw position
    float sOffset = s_centre - circleSize;
    float tOffset = t_centre;

    // Simplex noise
    if (distance(centrePoint, point(ss, tt, 0)) > (circleSize + ((rings - 1) * distanceBetweenRows)))
    {
        dispOut -= simHeight * (float)noise("usimplex", P * simFreq);
    }
/// PATTERN START
    else
    {
        for (int i = 0; i < rings; ++i)
        {
            float angle = radians(360 / circlesPerRing[i]);
            for (int j = 0; j < circlesPerRing[i]; ++j)
            {
                // Rotate surface
                rotPoint = rotate(stPoint, j * angle, centrePoint, axisPoint);
                rotS = rotPoint[0];
                rotT = rotPoint[1];

                // Draw circle
                float dist = distance(point(sOffset, tOffset, 0), point(rotS, rotT, 0));
                if (dist <= outerRadius && dist >= innerRadius)
                {
                    dispOut -= dist;
                }
            }
            sOffset -= distanceBetweenRows;
        }
    }
/// PATTERN END
}