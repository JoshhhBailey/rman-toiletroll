// The following shader is adapted from:
// Kesson, M., 2002. OSL Rosette. [online]
// Available from: https://www.fundza.com/rfm/osl/rosette/index.html
// Accessed [25 March 2021]

shader rollPattern(
    // Can be interpolated from an 's' or 't' variable attached to the geometry
    float s = 0 [[int lockgeom = 0]],
    float t = 0 [[int lockgeom = 0]],

    float s_repeats = 5,
    float t_repeats = 2,
    
    // Circle properties
    float innerRadius = 0.0,
    float outerRadius = 0.005,
    color circleColour = color(0.0, 0.0, 0.0),

    // Row properties
    int ringsPerCircle = 3,
    point circlesPerRing = point (18, 9, 0),    // Small = 18, 9, 0   Medium = 32, 22, 14   Large = 50, 44, 36
    float distanceBetweenRows = outerRadius * 5,

    color bgColour = color(1.0, 1.0, 1.0),
    output color resultRGB = 0)
{
    // Circle centre position
    float s_centre = 1.0;
    float t_centre = 0.0;

    // Mirroring
    float ss = mod(s * s_repeats, 1);
    float tt = mod(t * t_repeats, 1);

    float circleSize = (25 * outerRadius);
    point stPoint = point(ss, tt, 0);
    point rotPoint;
    float rotS;
    float rotT;

    resultRGB = bgColour;

    for (int rows = 0; rows < 3; ++rows)
    {
        for (int circlesPerRow = 0; circlesPerRow < 3; circlesPerRow++)
        {
            // Centre point of circle (to rotate around)
            point centrePoint = point(s_centre, t_centre, 0);
            point axisPoint = point(s_centre, t_centre, 1);

            // Draw position
            float sOffset = s_centre - circleSize;
            float tOffset = t_centre;

            for (int i = 0; i < ringsPerCircle; ++i)
            {
                float angle = radians(360 / circlesPerRing[i]);
                for (int j = 0; j < circlesPerRing[i]; ++j) {
                    // Rotate surface
                    rotPoint = rotate(stPoint, j * angle, centrePoint, axisPoint);
                    rotS = rotPoint[0];
                    rotT = rotPoint[1];

                    // Draw circle
                    float dist = distance(point(sOffset, tOffset, 0), point(rotS, rotT, 0));
                    if (dist <= outerRadius && dist >= innerRadius)
                    {
                        resultRGB = circleColour;
                    }
                }
                sOffset -= distanceBetweenRows;
            }
            t_centre += 0.5;
        }
        t_centre = 0.0;
        s_centre -= 0.5;
    }
}